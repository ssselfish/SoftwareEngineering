# Тема 8. Введение в ООП
Отчет по Теме #8 выполнил(а):
- Свинцова Софья Александровна
- ПИЭ-22-1

| Задание | Лаб_раб | Сам_раб |
| ------ |---------|---------|
| Задание 1 | +       | +       |
| Задание 2 | +       | +       |
| Задание 3 | +       | +       |
| Задание 4 | +       | +       |
| Задание 5 | +       | +       |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №8
#1.

```python
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model

my_car = Car("Toyota", "Corolla")
```
### Результат.

![Меню](https://github.com/ssselfish/SoftwareEngineering/blob/Тема_8/lab8/1.png)

### Вывод
Создается класс car с возможностью создавать объекты 

#2. 

```python
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model

    def drive(self):
        print(f"Driving the {self.make} {self.model}")

my_car = Car("Toyota", "Corolla")
my_car.drive()
```
### Результат.

![Меню](https://github.com/ssselfish/SoftwareEngineering/blob/Тема_8/lab8/2.png)

### Вывод
Создается класс car, затем объект my_car и вызывает метод drive

#3.

```python
class Car:
    def __init__(self, make, model):
        self.make = make
        self.model = model

    def drive(self):
        print(f"Driving the {self.make} {self.model}")
class ElectricCar(Car):
    def __init__(self, make, model, battery_capacity):
        super().__init__(make, model)
        self.battery_capacity = battery_capacity

    def charge(self):
        print(f"Charging the {self.make} {self.model} with {self.battery_capacity} kWh")

my_electric_car = ElectricCar("Tesla", "Model S", 75)
my_electric_car.drive()
my_electric_car.charge()
```
### Результат.

![Меню](https://github.com/ssselfish/SoftwareEngineering/blob/Тема_8/lab8/3.png)

### Вывод
Создается подкласс electriccar, где есть метод charge и атрибутом емкость батареи

#4.

```python
class Car:
    def __init__(self, make, model):
        self._make = make
        self.__model = model

    def drive(self):
        print(f"Driving the {self._make} {self.__model}")

my_car = Car("Toyota", "Corolla")

print(my_car._make)
my_car.drive()
```
### Результат.

![Меню](https://github.com/ssselfish/SoftwareEngineering/blob/Тема_8/lab8/4.png)

### Вывод
реализовали инкапсуляцию,делая атрибуты приватными

#5. 
```python
class Shape:
    def area(self):
        pass

class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius * self.radius

my_rectangle = Rectangle(10, 6)
my_circle = Circle(10)

print(my_rectangle.area())
print(my_circle.area())
```
### Результат.

![Меню](https://github.com/ssselfish/SoftwareEngineering/blob/Тема_8/lab8/5.png)

### Вывод
создаем первый класс, затем два класса наследника, в которых переопределяется метод area. Это демонстрирует применение полиморфизма.

## Самостоятельная работа №8
#1

```python
class students:
    def __init__(self, col):
        self.col = col

all_students = students(160)

print("Кол-во студентов на потоке:", all_students.col)
```
### Результат.

![Меню](https://github.com/ssselfish/SoftwareEngineering/blob/Тема_8/sam8/1.png)

### Вывод
создается класс students с атрибутом col(количество), затем создается объект all_students, где кол-во студентов равно 160, затем выводится кол-во студентов.

#2

```python
class student:
    def __init__(self, name, grade):
        self.name = name  
        self.grade = grade

    def get_name(self):
        return self.name

    def get_grade(self):
        return self.grade
    
my_student = student("Соня", 5.0)

print("Студент:", my_student.get_name())
print("Средний балл студента:", my_student.get_grade())
```
### Результат.

![Меню](https://github.com/ssselfish/SoftwareEngineering/blob/Тема_8/sam8/2.png)

### Вывод
создается класс student с атрибутами name и grade, методы get_name и get_grade возвращают имя и средний балл студента
  
#3

```python
class Student:
    def __init__(self, name, grade):
        self.name = name  
        self.grade = grade

    def get_name(self):
        return self.name

    def get_grade(self):
        return self.grade


class SeniorStudent(Student):
    def __init__(self, name, grade, year):
        super().__init__(name, grade)
        self.year = year

    def get_year(self):
        return self.year


my_student = SeniorStudent("Соня", 5.0, 3)

print("Студент:", my_student.get_name())
print("Средний балл студента:", my_student.get_grade())
print("Год обучения:", my_student.get_year())
```
### Результат.

![Меню](https://github.com/ssselfish/SoftwareEngineering/blob/Тема_8/sam8/3.png)

### Вывод
создается класс student с методом get_info, который возвращает информацию о студенте, подкласс seniorstudent наследует класс от student и добавляет атрибут year.
  
#4

```python
class Student:
    def __init__(self, name, grade):
        self._name = name
        self._grade = grade

    def get_name(self):
        return self._name

    def get_grade(self):
        return self._grade

    def set_grade(self, grade):
        self._grade = grade


class SeniorStudent(Student):
    def __init__(self, name, grade, year):
        super().__init__(name, grade)
        self._year = year

    def get_year(self):
        return self._year

    def set_year(self, year):
        self._year = year


my_student = SeniorStudent("Соня", 5.0, 3)

print("Студент:", my_student.get_name())
print("Средний балл студента:", my_student.get_grade())
print("Год обучения:", my_student.get_year())

my_student.set_grade(4.9)
my_student.set_year(4)

print("Новый средний балл студента:", my_student.get_grade())
print("Следующий год обучения:", my_student.get_year())
```
### Результат.

![Меню](https://github.com/ssselfish/SoftwareEngineering/blob/Тема_8/sam8/4.png)

### Вывод 
Атрибуты name, grade и year сделаны защищенными, также добавили методы set_grade и set_year для изменения оценки и года обучений
  
#5

```python
class Student:
    def __init__(self, name, grade):
        self._name = name
        self._grade = grade

    def get_name(self):
        return self._name

    def get_grade(self):
        return self._grade

    def study(self):
        return f"{self.get_name()} учится."

class SeniorStudent(Student):
    def __init__(self, name, grade, year):
        super().__init__(name, grade)
        self._year = year

    def get_year(self):
        return self._year

    def study(self):
        return f"{self.get_name()} готовится к выпускным экзаменам на {self.get_year()} курсе."

student1 = Student("Изольда", 4.5)
senior_student = SeniorStudent("Соня", 5.0, 4)

students = [student1, senior_student]

for student in students:
    print("Студент:", student.get_name())
    print("Средний балл студента:", student.get_grade())
    print(student.study())  
    print()  

senior_student._grade = 4.9
senior_student._year = 2025

print("Новый средний балл Сони:", senior_student.get_grade())
print("Следующий год обучения:", senior_student.get_year())
```
### Результат.

![Меню](https://github.com/ssselfish/SoftwareEngineering/blob/Тема_8/sam8/5.png)
### Вывод 
создается интерфейс student и поведение основных его методов, после этого создается реализация этого интерфейса seniorstudent, где уже переопределены методы.

## Общий вывод 
были изучены основные методы работы ооп на питоне: инкапсуляция, наследование и полиморфизм
 
